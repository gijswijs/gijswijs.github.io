<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content=""><link rel="shortcut icon" href=/favicon.ico><link rel=apple-touch-icon sizes=57x57 href=/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><meta name=msapplication-TileColor content=#ffffff><meta name=msapplication-TileImage content=/ms-icon-144x144.png><meta name=theme-color content=#ffffff><title>All types of multi-part payments in Lightning Network explained.</title><link href=/styles/main.css rel=stylesheet><link rel=alternate type=application/rss+xml title="Gijs van Dam" href=/rss.xml><link rel=webmention href=https://webmention.io/www.gijsvandam.nl/webmention><link rel=pingback href=https://webmention.io/www.gijsvandam.nl/xmlrpc><link rel=authorization_endpoint href=https://janos-githubproxy.azurewebsites.net/api/authorize/gijswijs/gijswijs.github.io><link rel=token_endpoint href=https://janos-githubproxy.azurewebsites.net/api/token/gijswijs/gijswijs.github.io><link rel=microsub href=https://aperture.p3k.io/microsub/636><link rel=micropub href=https://janos-githubproxy.azurewebsites.net/api/micropub/gijswijs/gijswijs.github.io></head><body class="article h-entry"><header>Gijs van Dam<nav><ul><li><a href=/ title=Home>Home</a></li><li><a href=/research title=Research>Research</a></li><li><a href=/open-source title="Open Source">Open Source</a></li><li><a href=/ventures title=Ventures>Ventures</a></li><li><a href=/resume title=Resume>Resume</a></li><li><a href=/about title=About>About</a></li><li><a href=/now title=Now>Now</a></li><li><a href=/contact title=Contact>Contact</a></li></ul></nav></header><main><article><script>MathJax = {
            chtml: {
              scale: 1, // global scaling factor for all expressions
              minScale: 1, // smallest scaling factor to use
            }
          };</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><header><h1 class=p-name>All types of multi-part payments in Lightning Network explained.</h1><span><a class=u-url href=/post/all-types-of-multi-part-payments-in-lightning-network-explained.><time class=dt-published datetime=2023-09-15T00:00:00Z>September 15, 2023</time></a> <span class=reading-time>10 minute read</span></span><ul><li><a class=p-category href=/topics/pss/ >PSS</a></li><li><a class=p-category href=/topics/lightning-network/ >lightning network</a></li><li><a class=p-category href=/topics/bitcoin/ >bitcoin</a></li><li><a class=p-category href=/topics/mpp/ >MPP</a></li><li><a class=p-category href=/topics/amp/ >AMP</a></li></ul></header><section class=e-content><p>Lightning Network uses source-based routing. What that means is that the sender is responsible for finding a route to the payee. But because the sender doesn&#39;t know the balances of all channels along a possible route, the proposed route can fail for lack of liquidity. So the sender is forced to try routes until it stumbles upon one that has enough liquidity to relay the payment; it&#39;s a process of trial and error. To increase the likelihood of success the idea of splitting up a payments into smaller parts was floated early on in the development of Lightning Network. The idea was that multiple smaller payments were more likely to succeed than one big payment. But you still want all separate parts of such a payment to act as one single atomic payment, that either succeeds completely or doesn&#39;t succeed at all.</p><p>This post assumes you have knowledge about how payments work in Lightning Network, especially HTLCs and pre-images. If you want to know more about how payments actually work in Lightning Network, you can check my other post on <a href=/post/how-do-payments-in-lightning-network-work/ title="How do payments in Lightning Network work?">Lightning Network payments</a>. In this post I will dive into the specific types of multi-part payments, as they are called, and explain a new type of multi-part payment that I developed. Also, if you look at what has been written on multi-part payments, you will see that multi-part and multi-path are used interchangeably. I think multi-part better describes what is happening, so I&#39;ll try to stick to that.</p><h2 id=base-mpp>Base MPP</h2><p>Probably the simplest form of multi-part payments (MPP) is Base MPP. That&#39;s why it&#39;s sometimes also referred to as <a href=https://bitcoinops.org/en/topics/multipath-payments/ title="Bitcoin Optech: Multipath payments">Simplified Multipath Payments</a> (SMP). It is the only type of MPP that is part of the official <a href=https://github.com/lightning/bolts/blob/master/04-onion-routing.md#basic-multi-part-payments title="BOLT #4: Basic Multi-Part Payments">Lightning Network specifications</a>, aka Basis of Lightning Technology (BOLT). The basic idea is that the sender uses multiple payments that combined are enough to buy the thing it wants. All those payments use the same payment hash, and a group of HTLCs which uses the same payment hash are called an HTLC set.</p><p>A sender can only use Base MPP if the receiver has shown support for it. The receiver does this by offering the <code>basic_mpp</code> feature in the invoice. The sender can now use multiple payments to pay the invoice. It should try to use diverse paths to the receiver, to increase the chances of success. The receiver, upon receiving the first HTLC out of the set, waits for at least 60 seconds for the other HTLCs from that set. If it receives them all, it reveals the pre-image to collect all of them. If it doesn&#39;t receive all HTLCs in time, it fails all HTLCs it <em>did</em> receive.</p><p>There is no cryptographic trickery that makes it impossible for the receiver to reveal the pre-image prematurely, but the receiver does have an economic incentive not to do so.</p><h2 id=link-mpp>Link MPP</h2><p>Base MPPs lesser known sibling is <a href=https://bitcoin.stackexchange.com/questions/98697/what-is-link-level-multiplexing title="What is Link-Level Multiplexing?">Link MPP</a>. Link MPP works in a situation where two nodes have two parallel channels between them. At some point one of the nodes gets asked to relay a payment to the other node, but none of the balances in either channel is sufficient. Instead of failing the payment, the nodes agree to use both channels to relay the payment in two parts using the same payment hash. The channel partner should wait until both HTLCs are received, before forwarding the payment further. Link MPP is different from Base MPP in a variety of ways. Base MPP uses different paths, while Link MPP is something that happens inside a hop (with parallel channels) that is part of a bigger path. More importantly, Base MPP is something that is initiated by the sender: it&#39;s the sender who breaks up the payment in different parts. Link MPP is initiated by the two channel partners and the sender doesn&#39;t need to (and won&#39;t) know about it, nor does the receiver. Also, Link MPP isn&#39;t part of the official <a href=https://github.com/lightning/bolts/blob/master/04-onion-routing.md#basic-multi-part-payments title="BOLT #4: Basic Multi-Part Payments">Lightning Network specifications</a> and I don&#39;t know of any client that supports it. But Link MPP can be (and maybe has been) implemented without it being part of the LN protocol. Two nodes can have their own Link MPP protocol that nobody needs to know about.</p><h2 id=atomic-multi-path-payments-the-og-mpp>Atomic Multi-Path Payments, the OG MPP</h2><p>Before Base MPP was a thing, Conner Fromknecht and Olaoluwa Osuntokun <a href=https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-February/000993.html title="AMP: Atomic Multi-Path Payments over Lightning">proposed AMP</a>. Because of this timeline, AMP is often referred to as Original AMP/MPP or OG AMP/MPP. AMP doesn&#39;t break the rule of re-using payment hashes. It also doesn&#39;t rely on an economic incentive for the receiver to ensure that the receiver gets paid in full.</p><p>It <a href=https://bitcoin.stackexchange.com/questions/89475/what-are-atomic-multi-path-payments-amps-and-why-how-is-it-being-implemented-i title="What are atomic multi path payments (AMPs) and why/how is it being implemented in Lightning Network?">works</a> by the sender making \(i\) number of payments parts. Each part is a payments with its own payment hash based on a pre-image created by the <em>sender</em>, but along with the payments hash, the sender also sends a secret \(s_i\) and the sequence number \(i\). The payments hash isn&#39;t the hash of a pre-image the receiver created, so the receiver is unable to collect a single part. But once the receiver has received <em>all</em> parts it can do a neat trick. It can take the XOR of all secrets and create the Base Secret (BS) \( BS = s_1 \oplus s_2 \oplus \cdots \oplus s_n \). It can then concatenate the BS with the sequence number \( SHA256(BP || i) \) to create each payments pre-image (which was how the sender created the pre-images to begin with). The big advantage of AMP is that the receiver is unable to collect any payment until it has received them all. The economic incentive argument can go out the window. It also doesn&#39;t re-use payment hashes.</p><p>AMP has one big downside. It is the sender who creates the secrets that XOR into a BS, and it also creates all the pre-images so that it can create the payment hashes for each payment. This means that the sender has knowledge of the pre-image <em>before</em> receiving the payment. This nullifies the concept of the pre-image being a cryptographic proof of payment.</p><h2 id=high-amp-amp-with-ptlcs>High AMP, AMP with PTLCs</h2><p>PTLCs deserve their own write-up, which I will get to in time, but here is a crash course. Let&#39;s start with claiming that PTLCs are HTLCs that replace the payment hash with a payment point. A payment point is a point on an elliptic curve (the secp256k1 curve to be exact). A point on an elliptic curve is the multiplication of some secret number <em>x</em> between \(0\) and \(\sim2^{256}\) and a base point <em>G</em> that is specific to the curve you are using. The payment point P now becomes \(P=xG\). So <em>P</em> is the public key of the private key <em>x</em>. You can read more about elliptic curve cryptography in my post on <a href=/post/why-does-signature-half-aggregation-break-adaptor-signatures/ title="Why does signature half aggregation break adaptor signatures?">signature aggregation</a>, but remember this one thing: It is easy to create the payment point <em>P</em> if you know <em>x</em>, but it is impossible to create the value <em>x</em> if you know <em>P</em>. Another thing you need to know is that elliptic curve points has this nice addition preserving property: \(xG + yG = (x+y)G\).</p><p>With PTLC the pre-image is <em>z</em>, and its public key \(Z=zG\) is shared through the invoice. Now if a sender wants to pay said invoice, it finds a route and for each hop in that route it creates a random nonce (\(x_1, x_2, \cdots , x_i\)). For the first hop the sender uses \(x_1G + Z = (x_1 + z)G\) as payment point, and it shares \(x_2\) with the first routing node. The first routing node now adds \(x_{2}G\) to the payment point of the PTLC it received and uses that as the payment point for the following hop, so that payment point becomes \((x_{1} + x_{2} + z)G\). The next routing node receives (\(x_3\) from the sender, and adds \(x_{3}G\) to the payment point. This continues until the receiver is reached with the payment point \((x_1 + x_2 + \cdots + x_i + z)G\). The sender shares \((x_1 + x_2 + \cdots + x_i)\) with the receiver. Note that this is different from what the routing nodes receive. They all received a single nonce, but the receiver gets the aggregate of all nonces.</p><p>Because the receiver knows <em>z</em>, we can now start the reveal phase. The receiver adds <em>z</em> to the aggregate of nonces it received from the sender. This is the secret it can use to collect the payment from the last routing node. The last routing node now learns \((x_1 + x_2 + \cdots + x_i + z)\) and already knows \(x_i\) (because the sender shared it) so it can subtract its nonce from the secret and that&#39;s the secret the last routing node can use to collect its payment. This continues untill the sender learns the secret to the first payment point: \((x_1 + z)\). The sender knows all nonces, so it definitely knows \(x_1\) and uses it to learn <em>z</em>. What&#39;s cool about the reveal of <em>z</em> in payments using PTLC, is that only the sender learns <em>z</em>, but none of the routing nodes do. So it&#39;s an even better proof of payment than the pre-image to a payment hash, because with HTLCs all the routing nodes learn the pre-image as well.</p><p>With payments points and PTLCs out of the way, let&#39;s explain how we can use this to create High AMP, which is OG AMP without its downsides. In a way, High AMP is just the combination of OG AMP with PTLCs:</p><p>The sender creates the Base Secret just like before. Using the BS it creates a pre-image for each payment part, also just like before (\( r_i = SHA256(BP || i) \)). Now the sender uses those pre-images to create points on the elliptic curve: \(r_{i}G\). For payment part <em>i</em> it adds \(r_{i}G\) to the payment point for the first hop. Routing of the payment continues as normal. So the receiver receives a payment with payment point \((r_i + x_{i_1} + x_{i_2} + \cdots + x_{i_j} + z)G\) for each of the payment parts. It can&#39;t collect any of them, because the receiver doesn&#39;t know \(r_i\). But just like with OG AMP, with each payment the payer also shares a secret \(s_i\) and the sequence number <em>i</em>. When the receiver has received all payment parts, it can construct the Base Secret <em>BS</em>, and can create all pre-images, and use them together with the knowledge of <em>z</em> to collect each payment part. Once the first payment part is revealed to the sender, the sender learns <em>z</em>, but not any time before. So <em>z</em> retains it power as a proof of payment! High AMP is the best of both worlds, it doesn&#39;t resort to an economic incentive to make payments atomic, but it retains the power of a cryptographic proof of payment.</p><p>But this is all still theoretical. PTLCs require adaptor signatures, and although it was already possible to do so, this was made a lot easier with the advent of Schnorr signatures in Bitcoin. Schnorr signatures were activated in Bitcoin in November 2021. Since then the LN community has focussed on other stuff first, but recently PTLCs were <a href=https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-September/004088.html title="Practical PTLCs, a little more concretely">put top-of-mind again</a>. But for now they are still &quot;just around the corner&quot;.</p><h2 id=payment-splitting--switching-pss>Payment Splitting &amp; Switching (PSS)</h2><p>In November 2018, ZmnSCPxj proposed a combination of <a href=https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001573.html title="Link-level payment splitting via intermediary rendezvous nodes">Link-level payment splitting and via intermediary rendezvous nodes</a>. The idea was that it would allow for &quot;payment splitting over multiple hops&quot; instead of payment splitting over parallel channels in the same hop. I liked the idea of it, but thought of it more as a combination of <a href=https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-March/001891.html title="Just in Time Routing (JIT-Routing) and a channel rebalancing heuristic as an add on for improved routing success in BOLT 1.0">Just In Time Routing</a> and Link MPP. Both ZmnSCPxj and Christian Decker were willing to <a href=https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-August/003144.html title="Revisiting Link-level payment splitting via intermediary rendezvous nodes">discuss the idea</a>, and it sounded feasible at the time, so I went on and created a <code>core lightning</code> <a href=https://github.com/gijswijs/plugins/tree/master/pss title="Payment Splitting &amp; Switching plugin">plugin</a> as a proof of concept.</p><p>To understand what the PSS plugin does, and how it&#39;s different from Link MPP, you have to first remember that the type of source based routing that LN uses, makes it impossible for any node along the route to know anything more than the previous and the next node in the route. So an intermediary node can never change the payment path to use an alternative route to the destination, because it has no idea what the destination is. But it <em>does</em> know what the next node is, and quite often there is an alternative non-direct route to the next node, e.g. a route with a single intermediary node.</p><p>PSS is similar to Link MPP in that two channel partners along a route agree to forward a payment in parts between them. One partner breaks up the payment in parts, the other reassembles them and forwards them as a single HTLC, as if nothing happened. Where PSS and Link MPP differ is that Link MPP only works with parallel channels, PSS also works with multi-hop routes.</p><p>My plugin is just a proof of concept and should definitely not be used with an actual <code>core lightning</code> node, but it did allow me to use it for my research on Balance Discovery Attacks and it had some real interesting implications. More on that in my next post.</p><h2 id=summary>Summary</h2><p>So that&#39;s MPP for you. Only Base MPP is a real thing, and maybe Link MPP is too and I just don&#39;t know about it. OG AMP has never come to fruition, but High AMP might once PTLCs become a thing. Meanwhile PSS is like Link MPP on steroids and it has a completely <em>not</em> battle tested plugin that shows it can work.</p></section></article></main><footer><nav><ul><li><a href=/ title=Home>Home</a></li><li><a href=/research title=Research>Research</a></li><li><a href=/open-source title="Open Source">Open Source</a></li><li><a href=/ventures title=Ventures>Ventures</a></li><li><a href=/resume title=Resume>Resume</a></li><li><a href=/about title=About>About</a></li><li><a href=/now title=Now>Now</a></li><li><a href=/contact title=Contact>Contact</a></li></ul></nav><ul><li><div itemscope itemtype=https://schema.org/Person><a itemprop=sameAs content=https://www.github.com/gijswijs href=https://www.github.com/gijswijs rel="noreferrer noopener me" target=_blank title=Github>Github</a></div></li><li><div itemscope itemtype=https://schema.org/Person><a itemprop=sameAs content=https://www.linkedin.com/in/gijsvandam/ href=https://www.linkedin.com/in/gijsvandam/ rel="noreferrer noopener me" target=_blank title=LinkedIn>LinkedIn</a></div></li><li><div itemscope itemtype=https://schema.org/Person><a itemprop=sameAs content=https://www.researchgate.net/profile/Gijs_Van_Dam2 href=https://www.researchgate.net/profile/Gijs_Van_Dam2 rel="noreferrer noopener me" target=_blank title=ResearchGate>ResearchGate</a></div></li><li><a href=/feed rel=feed target=_self title=Stream>Stream</a></li><li><a href=/rss.xml rel="" target=_blank title=RSS>RSS</a></li><li><div itemscope itemtype=https://schema.org/Person><a itemprop=sameAs content=https://keybase.io/gijsvandam href=https://keybase.io/gijsvandam rel="noreferrer noopener me" target=_blank title=Keybase>Keybase</a></div></li><li><div itemscope itemtype=https://schema.org/Person><a itemprop=sameAs content=https://orcid.org/0000-0002-6188-6859 href=https://orcid.org/0000-0002-6188-6859 rel="noreferrer noopener me" target=_blank title=ORCID>ORCID</a></div></li><li><div itemscope itemtype=https://schema.org/Person><a itemprop=sameAs content="https://scholar.google.com/citations?user=4dTcK4kAAAAJ&amp;hl=en" href="https://scholar.google.com/citations?user=4dTcK4kAAAAJ&amp;hl=en" rel="noreferrer noopener me" target=_blank title="Google Scholar">Google Scholar</a></div></li></ul><p>&copy; 2023 <a href=/ >Gijs van Dam</a>. Published with <a href=https://github.com/neumannjs/Janos>Janos</a>. Theme <a href=https://github.com/neumannjs/Miksa>Miksa</a>.</p></footer></body><script data-goatcounter=https://gijsvandam.goatcounter.com/count async src=//gc.zgo.at/count.js></script></html>